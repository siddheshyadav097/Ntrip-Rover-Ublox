/**
 *  @file          :  bat_api.c
 *  @author        :  Aakash/Ratna
 *  @date          :  01/04/2017
 *  @brief         :  Comprises application to monitor the status of the battery powering the system.
 *  				  APIs Init_Battery_Config is used to initialize the status and hardware for monitoring the battery state.
 *  				  BatteryMonitorHandler is the state machine which start at BATTERY_INIT state and is set in different states,
 *  				  on the basis of events generated by sensing the battery level and charging state.
 *  				  Get_BAT_Level provides the current battery level to the application.
 *  @filerevision  :  1.0
 *  
 */

 
 /*----includes-----*/
#include "bat_api.h"
#include "mem_config_api.h"
#include "qtimespent.h"
#include "led_api.h"
#include "debug_log.h"
 /*----variables-----*/
//uint8_t batteryLevel;
//BOOL retval = False;
batteryLevelState_et   batteryState = BATTERY_NORMAL;
vehicleBatteryState_et vehicleBatState = VEHICLE_BATTERY_CONNECTED;
//rfidReaderPwrState_et  rfidExtBattState =   RFID_POWER_CONNECTED;

uint32_t totalAdcBatCount = 0, totalAdcSupplyCount = 0;
uint32_t totalAdcVrefCount = 0;
uint32_t batAdcAvgResult, supplyAdcAvgResult,vrefAdcAvgResult;
uint8_t adcSampleCounter = 0;
uint32_t adcSampleStartTick = 0;
uint8_t batPercent = 0,battCalibrate = 0;
uint8_t pwrOnVtg = 0;
 uint16_t vrefint_cal;   
 SupplyInfo_st supplyInfo = {0};
 
 //variables to accumlate the raw adc counts
uint32_t totalAnalogIp1Count = 0;
uint32_t totalAnalogIp2Count = 0;
 
 //variables to accumlate the raw adc counts
uint32_t avgAnalogIp1Count = 0;
uint32_t avgAnalogIp2Count = 0;

extern ADC_HandleTypeDef hadc_supplysense;
 
extern  uint32_t tmp_index_adc_converted_data;

extern __IO   uint16_t   aADCxConvertedData[ADC_CONVERTED_DATA_BUFFER_SIZE]; /* ADC group regular conversion data (array of data) */


/* Variable to report ADC sequencer status */
uint8_t         ubSequenceCompleted = RESET;     /* Set when all ranks of the sequence have been converted */
 
 /* Variable to report status of DMA transfer of ADC group regular conversions */
/*  0: DMA transfer is not completed                                          */
/*  1: DMA transfer is completed                                              */
/*  2: DMA transfer has not yet been started yet (initial state)              */
__IO   uint8_t ubDmaTransferStatus = 2; /* Variable set into DMA interruption callback */

/*----private functions-----*/
 
/**
 *  @brief Sets the battery monitor state 
 *  @param [in] state contains 1 value of @ref batteryMonitorState_t enum
 *  typedef enum
    {
        BATTERY_INIT,
        BATTERY_OK,
        BATTERY_LOW,
        BATTERY_VERY_LOW
        BATTERY_EMPTY
        BATTERY_CHARGING,
        BATTERY_FULL
    }batteryMonitorState_t;
 *  @return void
 */
static void SetBatteryMonitorState(batteryLevelState_et state)
{
    if(state == batteryState)
    {
        return;
    }
    batteryState = state;
}

static void SetVehicleBatState(vehicleBatteryState_et state)
{
    if(state == vehicleBatState)
    {
        return;
    }
    vehicleBatState = state;
}

 /*----public functions-----*/
/*
 * Internal Reference Voltage, according to ST this is 1.21V typical
 * with -40°C<T<+105°C its Min: 1.18V, Typ 1.21V, Max: 1.24V
 */
void ADCGetVrefIntVtgCount(void)
{
  // VREFINT calibration value
    vrefint_cal= *((uint16_t*)VREFINT_CAL_ADDR); // read VREFINT_CAL_ADDR memory location
}
/**
 *  @brief This function calls the Init_BatterySensePort function to initialize the port & 
 *  sets the batteryMonitorState = BATTERY_INIT
 *  @return void
 */
void InitBatteryConfig(void)
{
    memset(&supplyInfo, 0, sizeof(SupplyInfo_st));
    adcSampleStartTick = GetStartTime();
    InitBattChargePin();
	  MX_DMA_Init();
    InitSupplySenseADCPorts();
    ADCGetVrefIntVtgCount();
    batteryState = BATTERY_NORMAL;
    vehicleBatState = VEHICLE_BATTERY_CONNECTED;
}
uint8_t ConvertBatAdcToPercent(float adcVal)
{
    batPercent = (uint8_t)(((adcVal - BATTERY_MIN_OPERATING_VOLTAGE)*100)/(BATTERY_MAX_OPERATING_VOLTAGE - BATTERY_MIN_OPERATING_VOLTAGE));
    return batPercent;
}

/**
 *  @brief  : converts the averaged battery adc value into percent
 *  @return : battery level in 0 to 100
 */
uint8_t GetBatteryLevel(void)
{
//    return (ConvertBatAdcToPercent(batAdcAvgResult));
      return supplyInfo.intBatLevel;
}

void GetSupplyVoltages(void)
{    
    /* Computation of ADC conversions raw data to physical values */
      /* Note: ADC results are transferred into array "adcValBuff"  */
      /*       in the order of their rank in ADC sequencer.                   */
      supplyInfo.intBatVoltage    = ComputeVolatge(batAdcAvgResult) * (54.0/39);//Resistor divider ratio for internal battery
      supplyInfo.mainIPVolt       = ComputeVolatge(supplyAdcAvgResult) *11;     //Resistor divider ratio for external battery
      supplyInfo.intBatLevel      = ConvertBatAdcToPercent(supplyInfo.intBatVoltage);
	    supplyInfo.analogIp1        = ComputeVolatge(avgAnalogIp1Count);//resistor divide  combination is changed 11;
      supplyInfo.analogIp2        = ComputeVolatge(avgAnalogIp2Count);//11
      supplyInfo.vrefIntVoltage   =(3.3 * ((float)vrefint_cal / (float)vrefAdcAvgResult));
      
     //LOG_INFO(CH_GSM,"UNIT VOLTAGES : %0.2f,%0.2f,%0.2f,%0.2f,%0.2f",supplyInfo.mainIPVolt,supplyInfo.intBatVoltage,supplyInfo.vrefIntVoltage,supplyInfo.analogIp1,supplyInfo.analogIp2);
	  //   LOG_CRIT(CH_GSM,"Pressure in (V) : %0.2f,%0.2f",supplyInfo.analogIp1,supplyInfo.analogIp2);
}


void SetBattLedState(batteryLevelState_et intBatStatus)
{
    if(intBatStatus == BATTERY_CHARGING)
	{
//		OnBattery = 0;
		Set_batteryLEDState(CHARGING_MODE);
	}
	else 
	{
//		OnBattery = 1;
		if(intBatStatus == BATTERY_FULL)
		{
			Set_batteryLEDState(CHARGE_COMPLETE);
		}
		else if(intBatStatus == BATTERY_LOW)
		{
			Set_batteryLEDState(BATT_LOW);
		}
		else
		{
			Set_batteryLEDState(BATT_MODE);
		}
	}
}

uint8_t MonitorUnitVoltage(void)
{
   if(pwrOnVtg == 1)  //this means cpu has started calibrating adc
   {
      if(supplyInfo.vrefIntVoltage >= 3.0)  //check if vdda analog reference vtg is greater than or equal to 3.0V max value is 3.3V
      {
        return 1;
      }
      else  //if both vtg's are down dont run the unit
      {
            return 0;
      }
   }
   return 0; 
}

/**
 *  @brief Queries the battery level & gets the values in battery_struct structure
 *  copies the value of capacity to batteryLevel. Also it changes the state of BatteryMonitorHandler
 *  depending on the value of batteryLevel & whether Charger is connected or not
 *  @return Return type will be 1 value of @ref batteryMonitorState_t enum
 */
void BatteryHandler(void)
{       
    if(TimeSpent(adcSampleStartTick,ADC_SAMPLE_INTERVAL_MS))//100 ms
    {
        TriggerSupplyADC();   //trigger the supply adc
        
        adcSampleStartTick  = GetStartTime();
        
       if(ubDmaTransferStatus == SET)
       {
				    totalAdcSupplyCount = totalAdcSupplyCount + ReadAdcSupplyValue(); 
            totalAdcBatCount    = totalAdcBatCount + ReadAdcBatValue();
				    totalAnalogIp1Count = totalAnalogIp1Count+ ReadTempSensorValue();
            //totalAnalogIp2Count = totalAnalogIp2Count + ReadAnalogIp2Value();
            totalAdcVrefCount   = totalAdcVrefCount+ ReadAdcVrefIntValue();
				 
//				    for (tmp_index_adc_converted_data = 0; tmp_index_adc_converted_data < ADC_CONVERTED_DATA_BUFFER_SIZE; tmp_index_adc_converted_data++)
//						{
//							aADCxConvertedData[tmp_index_adc_converted_data] = VAR_CONVERTED_DATA_INIT_VALUE;
//						}
						/* Update status variable of DMA transfer */
						
//						totalAdcSupplyCount = totalAdcSupplyCount + aADCxConvertedData[0]; 
//            totalAdcBatCount    = totalAdcBatCount + aADCxConvertedData[1]; 
//            totalAdcVrefCount   =totalAdcVrefCount + aADCxConvertedData[2]; 
						
									
            adcSampleCounter++;
            battCalibrate = 0;   //this flag is 0 unless averaged values are received in the buff
         
            if(adcSampleCounter >= NUM_BAT_ADC_SAMPLES_AVG) //10 average values equvalents to 1 second
            {
                batAdcAvgResult    = totalAdcBatCount/adcSampleCounter;
                supplyAdcAvgResult = totalAdcSupplyCount/adcSampleCounter;
							  avgAnalogIp1Count     = totalAnalogIp1Count/adcSampleCounter;
                //avgAnalogIp2Count     = totalAnalogIp2Count/adcSampleCounter;
                vrefAdcAvgResult   = totalAdcVrefCount/adcSampleCounter;
                  
                adcSampleCounter = 0;
							  totalAnalogIp1Count   = 0;
                totalAnalogIp2Count   = 0;
                totalAdcBatCount = 0;
                totalAdcSupplyCount = 0;
                totalAdcVrefCount = 0;
                                
                GetSupplyVoltages();
                
                supplyInfo.intBatStatus = BatteryStateHandler(supplyInfo.intBatLevel);   //get the battery status according to the bat level in %
                SetBattLedState(supplyInfo.intBatStatus); //toggle the led based on the batt status returned by BatteryStateHandler
                supplyInfo.mainPwrStatus   = VehicleBatStateHandler();
//                supplyInfo.ReaderPwrStatus = RfidReaderVoltageHandler();
                
                battCalibrate = 1;
                pwrOnVtg =1;
            }
            
            /* Reset variable for next loop iteration */
            ubDmaTransferStatus = RESET;
       }
      
    }
}
    
batteryLevelState_et BatteryStateHandler(uint8_t batteryLevel)
{
    switch(batteryState)
    {
        case BATTERY_NORMAL:
            if(IsChargerConnected())		// check whether charger is connected
            {
                SetBatteryMonitorState(BATTERY_CHARGING);
            }
            else if(batteryLevel < BATTERY_PERCENT_LOW)
            {
                SetBatteryMonitorState(BATTERY_LOW);
            }
        break;
        
        case BATTERY_LOW:
            if(IsChargerConnected())
            {
                SetBatteryMonitorState(BATTERY_CHARGING);
            }
            else if(batteryLevel > BATTERY_PERCENT_NORMAL)
            {
                SetBatteryMonitorState(BATTERY_NORMAL);
            }
	   break;
       
       case BATTERY_CHARGING:
            // check whether charger is disconnected
            if(IsChargerConnected() == 0)
            {
                SetBatteryMonitorState(BATTERY_NORMAL);
            }
            else if(IsChargingFull())
            {
                SetBatteryMonitorState(BATTERY_FULL);
            }
       break;
        
      case BATTERY_FULL:
            // check whether charger disconnected
            if(IsChargerConnected() == 0)
            {
                SetBatteryMonitorState(BATTERY_NORMAL);
            }
      break;
     }
      return batteryState;
}

vehicleBatteryState_et VehicleBatStateHandler(void)
{
  switch(vehicleBatState)
    {
        case VEHICLE_BATTERY_CONNECTED:
            if(supplyInfo.mainIPVolt <= VEHICLE_BATTERY_LOW_THRESHOLD)   //<=12.5
            {
                SetVehicleBatState(VEHICLE_BATTERY_DISCONNECTED);
            }
        break;
        
        case VEHICLE_BATTERY_DISCONNECTED:
            if(supplyInfo.mainIPVolt > VEHICLE_BATTERY_NORMAL_VOLTAGE)  //13
            {
                SetVehicleBatState(VEHICLE_BATTERY_CONNECTED);
            }
        break;
     }
      return vehicleBatState;
}

SupplyInfo_st* GetSupplyInfo(void)
{
  return(&supplyInfo);
}




